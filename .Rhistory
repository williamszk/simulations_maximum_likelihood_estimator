matrix1 = matrix(c(hold_mu1,hold_mu2,hold_mu3),ncol=3)
W1 = cov(matrix1,matrix1)
m_mu1 = mean(hold_mu1)
m_mu2 = mean(hold_mu1)
m_mu3 = mean(hold_mu1)
theta1 = c(0.055-m_mu1, 0.0489-m_mu2, 0.9165-m_mu3)
loss = t(theta1) %*% W1 %*% theta1
as.numeric(loss)
}
optimx(par, SMM_apply , gr=NULL, hess=NULL, lower=-Inf, upper=Inf,
method=c("Nelder-Mead","BFGS"))
mean(diff(cons)/cons[-290]) #0.00424719
plot(cons_xts)
which(cons==100)
cons
View(cons_xts)
cons_xts['20120101']
cons_xts['20120101'][1,1]==88.89971
cons_xts['20120101'][1,1]
as.numeric(cons_xts['20120101'][1,1])
aux_val1 = as.numeric(cons_xts['20120101'][1,1])
which(cons==aux_val1)
C_m[205]
aux_val1 = C_m[205] #position 20120101
C_m2 = C_m*(100/aux_val1)
C_m = C_m2
plot(C_m,type='l')
rho = 0.55    #values found by SMM
beta = 1.33
alpha = 0.8
Tp = 290 #same time periods of the real database
S = 100
hold_mu1 = double() #create holder vectors
hold_mu2 = double() #
hold_mu3 = double() #
C_m = rep(0,Tp) #create series of consumption
for (ii in 1:S) {
#set.seed(ii)
e = rnorm(Tp,0,0.1)
z = double()
z[1] = 0
for (t in 2:Tp) {
z[t] = rho*z[t-1] + e[t]
}
K = double()
K[1]=1
for (t in 2:Tp) {
K[t] = alpha*beta*exp(z[t-1])*K[t-1]^alpha
}
Y = double()
Y = exp(z)*K^alpha
C = double()
C = Y - K
C_m = C_m + C
C_m = C_m/S
}
aux_val1 = C_m[205] #position 20120101
C_m2 = C_m*(100/aux_val1)
C_m = C_m2
plot(C_m,type='l')
C_xts1 = xts(C_m, order.by = date)
macro_xts1 = cbind(cons_xts,C_xts1)
class(macro_xts1)
plot(macro_xts1)
plot(cons_xts)
#univariate
f = function(x){log(1+abs(x)^(s+sin(x)))}
x = seq(-5,5,by=.1)
y = f(x)
#univariate
f = function(x){log(1+abs(x)^(s+sin(x)))}
x = seq(-5,5,by=.1)
y = f(x)
#univariate
f = function(x){log(1+abs(x)^(2+sin(x)))}
x = seq(-5,5,by=.1)
y = f(x)
plot(x,y)
plot(x,y,type='l')
arctan(5)
atan(5)
f = function(x){(2+(sin(50*x)/50))(atan(x))^2 }
x = seq(-5,5,by=.1)
y = f(x)
plot(x,y,type='l')
f = function(x){(2+(sin(50*x)/50))(atan(x))^2 }
x = seq(-5,5,by=.1)
y = f(x)
f = function(x){(2+(sin(50*x)/50))*(atan(x))^2 }
x = seq(-5,5,by=.1)
y = f(x)
plot(x,y,type='l')
f = function(x){(2+(sin(50*x)/100))*(atan(x))^2 }
x = seq(-5,5,by=.1)
y = f(x)
plot(x,y,type='l')
f = function(x){(2+(sin(50*x)/20))*(atan(x))^2 }
x = seq(-5,5,by=.1)
y = f(x)
plot(x,y,type='l')
plot(x,y)
#multivariate functions
f = function(x){ x[1]^2 + x[2]^2 + x[1]*sin(x[2]) + x[2] * sin(x[1]) }
seq1 = seq(-5,5,by=.1)
x = cbind(seq1,seq1)
y = f(x)
library(plotly)
install.packages("plotly")
#190601 explore package plotly
library(plotly)
library(plotly)
# volcano is a numeric matrix that ships with R
p <- plot_ly(z = ~volcano) %>% add_surface()
# Create a shareable link to your chart
# Set up API credentials: https://plot.ly/r/getting-started
chart_link = api_create(p, filename="surface-1")
chart_link
x <- seq(-10, 10, length.out = 50)
y <- x
rotsinc <- function(x,y) {
sinc <- function(x) { y <- sin(x)/x ; y[is.na(y)] <- 1; y }
10 * sinc( sqrt(x^2+y^2) )
}
z <- outer(x, y, rotsinc)
persp(x, y, z)
library(rgl)
surface3d(x, y, z)
install.packages('rgl')
library(rgl)
surface3d(x, y, z)
?surface3d
data(volcano)
z <- 2 * volcano        # Exaggerate the relief
x <- 10 * (1:nrow(z))   # 10 meter spacing (S to N)
y <- 10 * (1:ncol(z))   # 10 meter spacing (E to W)
zlim <- range(y)
zlen <- zlim[2] - zlim[1] + 1
colorlut <- terrain.colors(zlen) # height color lookup table
col <- colorlut[ z - zlim[1] + 1 ] # assign colors to heights for each point
open3d()
surface3d(x, y, z, color = col, back = "lines")
surface3d(x, y, z, color='red') #red
volcano
class(volcano)
surface3d(z, color = col, back = "lines")
dim(volcano)
zlim <- range(y)
zlim
zlen <- zlim[2] - zlim[1] + 1
zlen
data(volcano)
z <- 2 * volcano        # Exaggerate the relief
x <- 10 * (1:nrow(z))   # 10 meter spacing (S to N)
y <- 10 * (1:ncol(z))   # 10 meter spacing (E to W)
zlim <- range(y)
zlen <- zlim[2] - zlim[1] + 1
colorlut <- terrain.colors(zlen) # height color lookup table
col <- colorlut[ z - zlim[1] + 1 ] # assign colors to heights for each point
open3d()
surface3d(x, y, z, color = col, back = "lines")
x <- (1:nrow(z))
y <- (1:ncol(z))
zlim <- range(y)
zlen <- zlim[2] - zlim[1] + 1
colorlut <- terrain.colors(zlen) # height color lookup table
col <- colorlut[ z - zlim[1] + 1 ] # assign colors to heights for each point
open3d()
surface3d(x, y, z, color = col, back = "lines")
zlim <- range(y)
zlim
zlim <- range(y)
zlim
y <- 10 * (1:ncol(z))   # 10 meter spacing (E to W)
zlim <- range(y)
zlim
data(volcano)
z <- 2 * volcano        # Exaggerate the relief
x <- 10 * (1:nrow(z))   # 10 meter spacing (S to N)
y <- 10 * (1:ncol(z))   # 10 meter spacing (E to W)
zlim <- range(y)
zlen <- zlim[2] - zlim[1] + 1
colorlut <- terrain.colors(zlen) # height color lookup table
col <- colorlut[ z - zlim[1] + 1 ] # assign colors to heights for each point
zlen
seq1 = seq(-5,5,by=.1)
x = cbind(seq1,seq1)
y = f(x)
z = f(x)
#multivariate functions
f = function(x){ x[1]^2 + x[2]^2 + x[1]*sin(x[2]) + x[2] * sin(x[1]) }
seq1 = seq(-5,5,by=.1)
x = cbind(seq1,seq1)
z = f(x)
surface3d(x[1], x[2], z)
open3d()
surface3d(x[1], x[2], z)
surface3d(x[,1], x[,2], z)
x[,2]
z
#multivariate functions
f = function(x){ x[,1]^2 + x[,2]^2 + x[,1]*sin(x[,2]) + x[,2] * sin(x[,1]) }
f
seq1 = seq(-5,5,by=.1)
x = cbind(seq1,seq1)
z = f(x)
z
#multivariate functions
f = function(x,y){ x^2 + y^2 + x*sin(y) + y * sin(x) }
seq1 = seq(-5,5,by=.1)
x = seq1
y = seq1
z = f(x)
z = f(x,y)
z
len_x1 = length(x)
len_x2 = length(y)
len_x = length(x)
len_y = length(y)
aux_matrix1 = matrix(rep(0,len_x*len_y),ncol=len_y)
aux_matrix1
len_x
dim(aux_matrix1)
aux_matrix1[1:5,1:5]
#multivariate functions
f = function(x,y){ x^2 + y^2 + x*sin(y) + y * sin(x) }
x = seq1
seq1 = seq(-5,5,by=.1)
y = seq1
z = f(x,y)
len_x = length(x)
len_y = length(y)
aux_matrix1 = matrix(rep(0,len_x*len_y),ncol=len_y)
for (ii in 1:len_x){
aux_x1 = x[ii]
for (jj in 1:len_y){
aux_y1 = y[jj]
aux_matrix1[ii,jj] = f(aux_x1,aux_y1)
}
}
z = aux_matrix1
open3d()
surface3d(x, y, z)
surface3d(x, y, z, color='red')
x = x*10
y = y*10
open3d()
surface3d(x, y, z, color='red')
surface3d(x, y, z, color='red',back = "lines")
surface3d(x, y, z, color='red',back = "lines")
f = function(x,y){(x^2 + y - 11)^2 + (x + y^2 - 7)^2  }
seq1 = seq(-5,5,by=.1)
seq1 = seq(-10,10,by=.1)
x = seq1
y = seq1
z = f(x,y)
len_x = length(x)
len_y = length(y)
aux_matrix1 = matrix(rep(0,len_x*len_y),ncol=len_y)
for (ii in 1:len_x){
aux_x1 = x[ii]
for (jj in 1:len_y){
aux_y1 = y[jj]
aux_matrix1[ii,jj] = f(aux_x1,aux_y1)
}
}
z = aux_matrix1
x = x*10
y = y*10
open3d()
surface3d(x, y, z, color='red',back = "lines")
x = x*1000
y = y*1000
open3d()
surface3d(x, y, z, color='red',back = "lines")
x = x*100
y = y*100
open3d()
surface3d(x, y, z, color='red',back = "lines")
x = x*50
y = y*50
#open3d()
surface3d(x, y, z, color='red',back = "lines")
x = x*20
y = y*20
#open3d()
surface3d(x, y, z, color='red',back = "lines")
x = x*20
y = y*20
#open3d()
surface3d(x, y, z, color='red',back = "lines")
x = x*20000
y = y*20000
#open3d()
surface3d(x, y, z, color='red',back = "lines")
f = function(x,y){(x^2 + y - 11)^2 + (x + y^2 - 7)^2  }
seq1 = seq(-10,10,by=.1)
x = seq1
y = seq1
z = f(x,y)
len_x = length(x)
len_y = length(y)
aux_matrix1 = matrix(rep(0,len_x*len_y),ncol=len_y)
for (ii in 1:len_x){
aux_x1 = x[ii]
for (jj in 1:len_y){
aux_y1 = y[jj]
aux_matrix1[ii,jj] = f(aux_x1,aux_y1)
}
}
z = aux_matrix1
x1 = x*20
y1 = y*20
#open3d()
surface3d(x1, y1, z, color='red',back = "lines")
x1 = x*200
y1 = y*200
#open3d()
surface3d(x1, y1, z, color='red',back = "lines")
x1 = x*2000
y1 = y*2000
#open3d()
surface3d(x1, y1, z, color='red',back = "lines")
x1 = x*1000
y1 = y*1000
#open3d()
surface3d(x1, y1, z, color='red',back = "lines")
x1 = x*100
y1 = y*100
#open3d()
surface3d(x1, y1, z, color='red',back = "lines")
f = function(x,y){(x^2 + y - 11)^2 + (x + y^2 - 7)^2  }
seq1 = seq(-10,10,by=.1)
x = seq1
y = seq1
z = f(x,y)
len_x = length(x)
len_y = length(y)
aux_matrix1 = matrix(rep(0,len_x*len_y),ncol=len_y)
for (ii in 1:len_x){
aux_x1 = x[ii]
for (jj in 1:len_y){
aux_y1 = y[jj]
aux_matrix1[ii,jj] = f(aux_x1,aux_y1)
}
}
z = aux_matrix1
x1 = x*1000
y1 = y*1000
#open3d()
surface3d(x1, y1, z, color='red',back = "lines")
f = function(x,y){(x^2 + y - 11)^2 + (x + y^2 - 7)^2  }
seq1 = seq(-10,10,by=.1)
x = seq1
y = seq1
z = f(x,y)
len_x = length(x)
len_y = length(y)
aux_matrix1 = matrix(rep(0,len_x*len_y),ncol=len_y)
for (ii in 1:len_x){
aux_x1 = x[ii]
for (jj in 1:len_y){
aux_y1 = y[jj]
aux_matrix1[ii,jj] = f(aux_x1,aux_y1)
}
}
z = aux_matrix1
x1 = x*1000
y1 = y*1000
#open3d()
surface3d(x1, y1, z, color='red',back = "lines")
#another function -------------------------------------------------------
f = function(x,y){ (1-x)^2 + 100*(y-x^2)^2}
seq1 = seq(-10,10,by=.1)
x = seq1
y = seq1
z = f(x,y)
len_x = length(x)
len_y = length(y)
aux_matrix1 = matrix(rep(0,len_x*len_y),ncol=len_y)
for (ii in 1:len_x){
aux_x1 = x[ii]
for (jj in 1:len_y){
aux_y1 = y[jj]
aux_matrix1[ii,jj] = f(aux_x1,aux_y1)
}
}
z = aux_matrix1
x1 = x*1000
y1 = y*1000
#open3d()
surface3d(x1, y1, z, color='red',back = "lines")
#open3d()
surface3d(x1, y1, z, color='red',back = "lines")
x1 = x*100000
y1 = y*100000
#open3d()
surface3d(x1, y1, z, color='red',back = "lines")
x1 = x*10000
y1 = y*10000
#open3d()
surface3d(x1, y1, z, color='red',back = "lines")
x1 = x*50000
y1 = y*50000
#open3d()
surface3d(x1, y1, z, color='red',back = "lines")
f = function(x,y){ (1-x)^2 + 100*(y-x^2)^2}
seq1 = seq(-5,5,by=.1)
x = seq1
y = seq1
z = f(x,y)
len_x = length(x)
len_y = length(y)
aux_matrix1 = matrix(rep(0,len_x*len_y),ncol=len_y)
for (ii in 1:len_x){
aux_x1 = x[ii]
for (jj in 1:len_y){
aux_y1 = y[jj]
aux_matrix1[ii,jj] = f(aux_x1,aux_y1)
}
}
z = aux_matrix1
x1 = x*50000
y1 = y*50000
#open3d()
surface3d(x1, y1, z, color='red',back = "lines")
f = function(x,y){ (1-x)^2 + 100*(y-x^2)^2}
seq1 = seq(-5,5,by=.1)
x = seq1
y = seq1
z = f(x,y)
len_x = length(x)
len_y = length(y)
aux_matrix1 = matrix(rep(0,len_x*len_y),ncol=len_y)
for (ii in 1:len_x){
aux_x1 = x[ii]
for (jj in 1:len_y){
aux_y1 = y[jj]
aux_matrix1[ii,jj] = f(aux_x1,aux_y1)
}
}
z = aux_matrix1
x1 = x*5000
y1 = y*5000
#open3d()
surface3d(x1, y1, z, color='red',back = "lines")
f = function(x,y){ (1-x)^2 + 100*(y-x^2)^2}
seq1 = seq(-5,5,by=.1)
x = seq1
y = seq1
z = f(x,y)
len_x = length(x)
len_y = length(y)
aux_matrix1 = matrix(rep(0,len_x*len_y),ncol=len_y)
for (ii in 1:len_x){
aux_x1 = x[ii]
for (jj in 1:len_y){
aux_y1 = y[jj]
aux_matrix1[ii,jj] = f(aux_x1,aux_y1)
}
}
z = aux_matrix1
x1 = x*5000
y1 = y*5000
#open3d()
surface3d(x1, y1, z, color='red',back = "lines")
#another function -------------------------------------------------------
f = function(x,y){.26*(x^2+y^2)+.48*x*y}
seq1 = seq(-5,5,by=.1)
x = seq1
y = seq1
z = f(x,y)
len_x = length(x)
len_y = length(y)
len_x = length(x)
len_y = length(y)
aux_matrix1 = matrix(rep(0,len_x*len_y),ncol=len_y)
for (ii in 1:len_x){
aux_x1 = x[ii]
for (jj in 1:len_y){
aux_y1 = y[jj]
aux_matrix1[ii,jj] = f(aux_x1,aux_y1)
}
}
z = aux_matrix1
x1 = x*5000
y1 = y*5000
#open3d()
surface3d(x1, y1, z, color='red',back = "lines")
x1 = x*100
y1 = y*100
#open3d()
surface3d(x1, y1, z, color='red',back = "lines")
x1 = x*100
y1 = y*100
#open3d()
surface3d(x1, y1, z, color='red',back = "lines")
x1 = x*10
y1 = y*10
#open3d()
surface3d(x1, y1, z, color='red',back = "lines")
x1 = x*1
y1 = y*1
#open3d()
surface3d(x1, y1, z, color='red',back = "lines")
x1 = x*1
y1 = y*1
#open3d()
surface3d(x1, y1, z, color='red',back = "lines")
x1 = x*2
y1 = y*2
#open3d()
surface3d(x1, y1, z, color='red',back = "lines")
